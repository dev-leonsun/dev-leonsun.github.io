{"posts":[{"title":"Javase复习--chapter2 面向对象","content":"Javase复习P2 面向对象 1.概述 1.1面向对象三大特征 ①封装（Encapsulation） ②继承（Inheritance） 多态（Polymorphism） 1.2类和对象 ①类 ①现实世界中，事物与事物之间具有共同特征，例如：刘德华和梁朝伟都有姓名、身份证号、身高等状态，都有吃、跑、跳等行为。将这些共同的状态和行为提取出来，形成了一个模板，称为类。 ②类实际上是人类大脑思考总结的一个模板，类是一个抽象的概念。 ③状态在程序中对应属性。属性通常用变量来表示。 ④行为在程序中对应方法。用方法来描述行为动作。 ⑤类 = 属性 + 方法。 ②对象 ①实际存在的个体。 ②对象又称为实例（instance）。 ③通过类这个模板可以实例化n个对象。（通过类可以创造多个对象） ④例如通过“明星类”可以创造出“刘德华对象”和“梁朝伟对象”。 ⑤明星类中有一个属性姓名：String name; ⑥“刘德华对象”和“梁朝伟对象”由于是通过明星类造出来的，所以这两个 都有name属性，但是值是不同的。因此这种属性被称为实例变量。 对象的内存分析 对象存在堆，class 存在元空间，方法压栈，执行内部代码，局部变量在栈帧，引用对象指向堆，静态变量存在堆，出栈。 类加载的过程 装载（loading） 类加载器负责将所有系统类，平台类，应用类的class文件读入内存，并创建一个java.lang.Class对象 连接(linking) 验证（Verify） 确保加载类的信息符合JVM规范。 准备（Prepare） 正式为静态变量在方法区中开辟存储空间并设置默认值，为静态常量开辟空间并赋值 public static int k = 10; 此时：k会赋值0 public static final int f = 10; 此时： f会赋值10 解析（Resolve） 将虚拟机常量池内的符号引用替换为直接引用（地址）的过程。 初始化（initialization） 静态变量赋值，静态代码块执行 低版本的JDK中类加载器的名字： 启动类加载器：负责加载rt.jar 扩展类加载器：ext/*.jar 系统类加载器：classpath package com.powernode.javase.oop01; /* 1. 定义类的语法格式： [修饰符列表] class 类名{ 类体 = 属性 + 方法; // 属性（实例变量），描述的是状态 // 方法，描述的是行为动作 } 2. 为什么要定义类？ 因为要通过类实例化对象。有了对象，让对象和对象之间协作起来形成系统。 3. 一个类可以实例化多个java对象。（通过一个类可以造出多个java对象。） 4. 实例变量是一个对象一份，比如创建3个学生对象，每个学生对象中应该都有name变量。 5. 实例变量属于成员变量，成员变量如果没有手动赋值，系统会赋默认值 数据类型 默认值 ---------------------- byte 0 short 0 int 0 long 0L float 0.0F double 0.0 boolean false char \\u0000 引用数据类型 null */ public class Student { // 属性：姓名，年龄，性别，他们都是实例变量 // 姓名 String name; // 年龄 int age; // 性别 boolean gender; } package com.powernode.javase.oop01; public class StudentTest01 { public static void main(String[] args) { // 局部变量 int i = 10; // 通过学生类Student实例化学生对象（通过类创造对象） // Student s1; 是什么？s1是变量名。Student是一种数据类型名。属于引用数据类型。 // s1也是局部变量。和i一样。 // s1变量中保存的是：堆内存中Student对象的内存地址。 // s1有一个特殊的称呼：引用 // 什么是引用？引用的本质上是一个变量，这个变量中保存了java对象的内存地址。 // 引用和对象要区分开。对象在JVM堆当中。引用是保存对象地址的变量。 Student s1 = new Student(); // 访问对象的属性（读变量的值） // 访问实例变量的语法：引用.变量名 // 两种访问方式：第一种读取，第二种修改。 // 读取：引用.变量名 s1.name; s1.age; s1.gender; // 修改：引用.变量名 = 值; s1.name = &quot;jack&quot;; s1.age = 20; s1.gender = true; System.out.println(&quot;姓名：&quot; + s1.name); // null System.out.println(&quot;年龄：&quot; + s1.age); // 0 System.out.println(&quot;性别：&quot; + (s1.gender ? &quot;男&quot; : &quot;女&quot;)); // 修改对象的属性（修改变量的值，给变量重新赋值） s1.name = &quot;张三&quot;; s1.age = 20; s1.gender = true; System.out.println(&quot;姓名：&quot; + s1.name); // 张三 System.out.println(&quot;年龄：&quot; + s1.age); // 20 System.out.println(&quot;性别：&quot; + (s1.gender ? &quot;男&quot; : &quot;女&quot;)); // 男 // 再创建一个新对象 Student s2 = new Student(); // 访问对象的属性 System.out.println(&quot;姓名=&quot; + s2.name); // null System.out.println(&quot;年龄=&quot; + s2.age); // 0 System.out.println(&quot;性别=&quot; + (s2.gender ? &quot;男&quot; : &quot;女&quot;)); // 修改对象的属性 s2.name = &quot;李四&quot;; s2.age = 20; s2.gender = false; System.out.println(&quot;姓名=&quot; + s2.name); // 李四 System.out.println(&quot;年龄=&quot; + s2.age); // 20 System.out.println(&quot;性别=&quot; + (s2.gender ? &quot;男&quot; : &quot;女&quot;)); // 女 } } 封装 面向对象三大特征之一：封装 ①现实世界中封装： 液晶电视也是一种封装好的电视设备，它将电视所需的各项零部件封装在一个整体的外壳中，提供给用户一个简单而便利的使用接口，让用户可以轻松地切换频道、调节音量、等。液晶电视内部包含了很多复杂的技术，如显示屏、LED背光模块、电路板、扬声器等等，而这些内部结构对于大多数普通用户来说是不可见的，用户只需要通过遥控器就可以完成电视的各种设置和操作，这就是封装的好处。液晶电视的封装不仅提高了用户的便利程度和使用效率，而且还起到了保护设备内部部件的作用，防止灰尘、脏物等干扰。同时，液晶电视外壳材料的选择也能起到防火、防潮、防电等效果，为用户的生活带来更安全的保障。 ②什么是封装？ 封装是一种将数据和方法加以包装，使之成为一个独立的实体，并且把它与外部对象隔离开来的机制。具体来说，封装是将一个对象的所有“状态（属性）”以及“行为（方法）”统一封装到一个类中，从而隐藏了对象内部的具体实现细节，向外界提供了有限的访问接口，以实现对对象的保护和隔离。 ③封装的好处？ 封装通过限制外部对对象内部的直接访问和修改，保证了数据的安全性，并提高了代码的可维护性和可复用性。 ④在代码上如何实现封装？ 属性私有化，对外提供getter和setter方法。 构造方法 构造方法Constructor(构造器) ①构造方法有什么作用？ 1.构造方法的执行分为两个阶段：对象的创建和对象的初始化。这两个阶段不能颠倒，也不可分割。 2.在Java中，当我们使用关键字new时，就会在内存中创建一个新的对象，虽然对象已经被创建出来了，但还没有被初始化。而初始化则是在执行构造方法体时进行的。 ②构造方法如何定义？ [修饰符列表] 构造方法名(形参){} ③构造方法如何调用？new 构造方法名(实参); ④关于无参数构造方法：如果一个类没有显示的定义任何构造方法，系统会默认提供一个无参数构造方法，也被称为缺省构造器。一旦显示的定义了构造方法，则缺省构造器将不存在。为了方便对象的创建，建议将缺省构造器显示的定义出来。 ⑤构造方法支持重载机制。 ⑥关于构造代码块。对象的创建和初始化过程梳理： ①new的时候在堆内存中开辟空间，给所有属性赋默认值 ②执行构造代码块进行初始化 ③执行构造方法体进行初始化 构造方法执行结束，对象初始化完毕。 对象创建的过程 在类完成初始化后，开始执行方法，在栈帧中操作 ①new运算符会在JVM的堆内存中分配空间用来存储实例变量。new分配的空间就是Java对象。 ②在JVM中对象创建后会有对应的内存地址，将内存地址赋值给一个变量，这个变量被称为引用。 ③Java中的GC主要针对的是JVM的堆内存。 ④空指针异常是如何发生的？ ⑤方法调用时参数是如何传递的？将变量中保存的值复制一份传递过去。 ⑥初次认识this关键字：出现在实例方法中，代表当前对象。“this.”大部分情况下可以省略。 this存储在实例方法栈帧的局部变量表的0号槽位上。 static关键字 static关键字 ①static是一个关键字，翻译为：静态的。 ②static修饰的变量叫做静态变量。当所有对象的某个属性的值是相同的，建议将该属性定义为静态变量，来节省内存的开销。 ③静态变量在类加载时初始化，存储在堆中。！！！！ ④static修饰的方法叫做静态方法。 ⑤所有静态变量和静态方法，统一使用“类名.”调用。虽然可以使用“引用.”来调用，但实际运行时和对象无关，所以不建议这样写，因为这样写会给其他人造成疑惑。 ⑥使用“引用.”访问静态相关的，即使引用为null，也不会出现空指针异常。 ⑦静态方法中不能使用this关键字。因此无法直接访问实例变量和调用实例方法。 ⑧静态代码块在类加载时执行，一个类中可以编写多个静态代码块，遵循自上而下的顺序依次执行。 ⑨静态代码块代表了类加载时刻，如果你有代码需要在此时刻执行，可以将该代码放到静态代码块中。 jvm的体系结构 JVM对应了一套规范（Java虚拟机规范），它可以有不同的实现 ①JVM规范是一种抽象的概念，它可以有多种不同的实现。例如： 1.HotSpot：HotSpot 由 Oracle 公司开发，是目前最常用的虚拟机实现，也是默认的 Java 虚拟机，默认包含在 Oracle JDK 和 OpenJDK 中 这是常用的 2.JRockit：JRockit 也是由 Oracle 公司开发。它是一款针对生产环境优化的 JVM 实现，能够提供高性能和可伸缩性 3.IBM JDK：IBM JDK 是 IBM 公司开发的 Java 环境，采用了与 HotSpot 不同的 J9 VM，能够提供更小的内存占用和更迅速的启动时间 4.Azul Zing：Azul Zing 是针对生产环境优化的虚拟机实现，能够提供高性能和实时处理能力，适合于高负载的企业应用和实时分析等场景 5.OpenJ9：OpenJ9 是由 IBM 开发的优化的 Java 虚拟机实现，支持高度轻量级、低时延的 GC、优化的 JIT 编译器和用于健康度测试的可观察性仪表板 ②右图是从oracle官网上截取的Java虚拟机规范中的一部分。（大家也可以找一下oracle官方文档） ③我们主要研究运行时数据区。运行时数据区包括6部分： 1.The pc Register（程序计数器） 2.Java Virtual Machine Stacks（Java虚拟机栈） 3.Heap（堆） 4.Method Area（方法区） 5.Run-Time Constant Pool（运行时常量池） 6.Native Method Stacks（本地方法栈） ①The pc Register（程序计数器）：是一块较小的内存空间，此计数器记录的是正在执行的虚拟机字节码指令的地址； ②Java Virtual Machine Stacks（Java虚拟机栈）：Java虚拟机栈用于存储栈帧。栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 ③Heap（堆）：是Java虚拟机所管理的最大的一块内存。堆内存用于存放Java对象实例以及数组。堆是垃圾收集器收集垃圾的主要区域。 ④Method Area（方法区）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 ⑤Run-Time Constant Pool（运行时常量池）：是方法区的一部分，用于存放编译期生成的各种字面量与符号引用。 ⑥Native Method Stacks（本地方法栈）：在本地方法的执行过程中，会使用到本地方法栈。和 Java 虚拟机栈十分相似。 HotSpot（Oracle JDK/Open JDK内部使用的JVM就是HotSpot） jdk8以后 年轻代：刚new出来的对象放在这里。 老年代：经过垃圾回收之后仍然存活的对象。 符号引用：类全名，字段全名，方法全名等。 方法区的实现转移到本地内存 继承 ①面向对象三大特征之一：继承 ②继承作用？ l基本作用：代码复用 l重要作用：有了继承，才有了方法覆盖和多态机制。 ③继承在java中如何实现？ l[修饰符列表] class 类名 extends 父类名{} extends翻译为扩展。表示子类继承父类后，子类是对父类的扩展。 ④继承相关的术语：当B类继承A类时 A类称为：父类、超类、基类、superclass B类称为：子类、派生类、subclass ⑤Java只支持单继承，一个类只能直接继承一个类。 ⑥Java不支持多继承，但支持多重继承（多层继承）。 ⑦子类继承父类后，除私有的不支持继承、构造方法不支持继承。其它的全部会继承。 ⑧一个类没有显示继承任何类时，默认继承java.lang.Object类。 override ①什么情况下考虑使用方法覆盖？ 1.当从父类中继承过来的方法无法满足当前子类的业务需求时。 ②发生方法覆盖的条件？ 1.具有继承关系的父子类之间 2.相同的返回值类型，相同的方法名，相同的形式参数列表 3.访问权限不能变低，可以变高。 4.抛出异常不能变多，可以变少。 5.返回值类型可以是父类方法返回值类型的子类。 ③方法覆盖的小细节： 1.@Override注解标注的方法会在编译阶段检查该方法是否重写了父类的方法。 2.私有方法不能继承，所以不能覆盖。 3.构造方法不能继承，所以不能覆盖。 4.静态方法不存在方法覆盖，方法覆盖针对的是实例方法。 class Parent { public static void show() { System.out.println(&quot;Parent show&quot;); } } class Child extends Parent { // public static void show() { // System.out.println(&quot;Child show&quot;); // } } public class Main { public static void main(String[] args) { Child p = new Child(); p.show(); // 输出 &quot;Parent show&quot; } } 如果子类中没有重新写父类的静态方法，通过子类调用时自动调用父类的，因为在某个类中定义的静态方法，是属于这个类的，也可以说静态方法是一种伪继承 方法覆盖说的实例方法，和实例变量无关。 多态学习 ① 向上转型和向下转型 在Java中，具有继承关系的父子类型之间可以进行类型转换。这种类型转换分为向上转型（upcasting）**和**向下转型（downcasting）。 1. 向上转型（Upcasting） 定义：子类对象可以赋值给父类类型的引用，这种转换是隐式的，不需要使用强制类型转换符。 语法： Parent parent = new Child(); 特点： 向上转型是安全的，因为子类对象本身就包含了父类的所有属性和方法。 通过父类引用只能访问父类中定义的成员（包括字段和方法），无法访问子类特有的成员。 编译器允许这种转换，因为它知道子类是父类的扩展。 示例： class Animal { public void move() { System.out.println(&quot;Animal is moving&quot;); } } class Cat extends Animal { public void meow() { System.out.println(&quot;Cat is meowing&quot;); } } public class Main { public static void main(String[] args) { Animal a = new Cat(); // 向上转型 a.move(); // 调用的是Cat类的move()方法（多态） // a.meow(); // 错误：编译时，a被看作Animal类型，没有meow()方法 } } 2. 向下转型（Downcasting） 定义：父类类型的引用可以转换为子类类型的引用，但这种转换是显式的，需要使用强制类型转换符。 语法： Child child = (Child) parent; 特点： 向下转型不是总是安全的，只有当父类引用实际指向的是子类对象时，才能成功转换。 如果父类引用实际指向的不是子类对象，运行时会抛出ClassCastException异常。 为了确保安全性，通常会在向下转型前使用instanceof关键字进行类型检查。 示例： class Animal { public void move() { System.out.println(&quot;Animal is moving&quot;); } } class Cat extends Animal { public void meow() { System.out.println(&quot;Cat is meowing&quot;); } } public class Main { public static void main(String[] args) { Animal a = new Cat(); // 向上转型 if (a instanceof Cat) { // 检查a是否是Cat类型 Cat c = (Cat) a; // 向下转型 c.move(); // 调用的是Cat类的move()方法 c.meow(); // 调用Cat类特有的meow()方法 } } } 3. 转型的前提条件 无论是向上转型还是向下转型，前提条件是两种类型之间必须存在继承关系。否则，编译器将无法编译通过。 ② 多态 1. 定义 多态指的是一个父类类型的引用可以指向多个不同子类的对象，并且在运行时根据实际对象的类型调用相应的方法。这是Java中实现动态绑定的关键机制。 语法： Parent reference = new Child(); reference.method(); 解释： Parent reference 是父类类型的引用。 new Child() 创建了一个子类对象。 reference.method() 调用的是子类对象的实际方法，而不是父类中的方法。 2. 编译阶段与运行阶段 多态的实现涉及到两个阶段：编译阶段和运行阶段。 编译阶段： 编译器只知道引用的声明类型（即父类类型），因此它会去父类中查找方法签名。如果找到该方法，编译器会认为调用是合法的，并绑定到该方法。 这个过程称为静态绑定或早期绑定。 因为编译阶段会将静态方法和类绑定，所以下面的代码中： b对象在编译时，静态方法已经和B绑定 public class test1 { public static void main(String[] args) { A a = new A(); a.test();// 输出 A=&gt;test() B b = new A(); b.test();// 输出 B=&gt;test()，说明父类中的test()方法没有被重写 B c =new B(); c.test(); } } // 父类 class B { public static void test(){ System.out.println(&quot;B=&gt;test()&quot;); } } // 子类 class A extends B { public static void test(){ System.out.println(&quot;A=&gt;test()&quot;); } } 运行阶段： 在运行时，JVM会根据实际对象的类型来决定调用哪个方法。即使引用是父类类型，JVM也会调用子类中重写的方法。 这个过程称为动态绑定或晚期绑定。 示例： class Animal { public void move() { System.out.println(&quot;Animal is moving&quot;); } } class Cat extends Animal { @Override public void move() { System.out.println(&quot;Cat is running&quot;); } } class Dog extends Animal { @Override public void move() { System.out.println(&quot;Dog is walking&quot;); } } public class Main { public static void main(String[] args) { Animal a1 = new Cat(); // 父类引用指向子类对象 Animal a2 = new Dog(); // 父类引用指向另一个子类对象 a1.move(); // 输出 &quot;Cat is running&quot;（多态） a2.move(); // 输出 &quot;Dog is walking&quot;（多态） } } 3. 多态的特点 多种形态：在编译阶段，编译器只知道引用的声明类型；而在运行阶段，JVM会根据实际对象的类型调用相应的方法。因此，同一个父类引用可以在不同的情况下表现出不同的行为，这就是“多态”的含义。 实例变量（字段）没有多态性，而只有 方法有动态绑定（多态性）。 public class Main { public static void main(String[] args) { Parent p = new Child(); Animal cat=new Cat(&quot;cat&quot;,&quot;white&quot;); cat.move(); System.out.println(cat.A);//输出的是parent 因为方法有多态，属性没有 //Parent constructor执行 子类型对象执行时如果没有重新定义构造方法，会自动使用父类型的构造方法 //Parent constructor System.out.println(p.a); } } class Animal { protected String name; String A=&quot;parent&quot;; public Animal(String name,String A) { this.name = name; this.A=A; } public void move() { System.out.println(name + &quot; is moving&quot;); } } class Cat extends Animal { String A=&quot;child&quot;; private String color; protected String name; // 调用父类的构造方法 public Cat(String name, String color) { super(name,&quot;parent------&quot;); this.color = color; } // 重写父类的方法 @Override public void move() { super.move(); // 调用父类的 move() 方法 System.out.println(&quot;The cat is running&quot;); } // 访问父类的成员变量 public void printInfo() { System.out.println(&quot;Name: &quot; + super.name + &quot;, Color: &quot; + this.color); } } 灵活性：多态使得代码更加灵活和可扩展。你可以在不修改现有代码的情况下，添加新的子类，并且这些新类可以无缝地融入现有的系统中。 动态绑定：多态的核心是动态绑定，即在运行时根据实际对象的类型来决定调用哪个方法，而不是在编译时确定。 总结 向上转型：子类对象可以赋值给父类类型的引用，无需强制类型转换。 向下转型：父类类型的引用可以转换为子类类型的引用，但需要强制类型转换，并且必须确保实际对象是子类类型。 多态：父类类型的引用可以指向多个不同子类的对象，并且在运行时根据实际对象的类型调用相应的方法。多态的实现依赖于动态绑定，使得代码更加灵活和可扩展。 super关键字 super关键字 ①super关键字和this关键字对比来学习。this代表的是当前对象。super代表的是当前对象中的父类型特征。 ②super不能使用在静态上下文中。 ③“super.”大部分情况下是可以省略的。什么时候不能省略？ ①当父类和子类中定义了相同的属性（实例变量）或者相同方法（实例方法）时，如果需要在子类中访问父类的属性或方法时，super.不能省略。 ④this可以单独输出，super不能单独输出。 ⑤super(实参); 通过子类的构造方法调用父类的构造方法，目的是为了完成父类型特征的初始化。 ⑥当一个构造方法第一行没有显示的调用“super(实参);”，也没有显示的调用“this(实参)”，系统会自动调用super()。因此一个类中的无参数构造方法建议显示的定义出来。 ⑦如果比作盒子，继承对象实际上相当于在父类盒子中塞入了一个小盒子，这个小盒子要完成大盒子中对象的填充 ⑧在Java语言中只要new对象，Object的无参数构造方法一定会执行。因为所有类都是object的子类，那么首先就要完成object类的构造方法 super 关键字与 this 关键字对比学习 1. this 关键字 定义：this 关键字代表当前对象的引用，即指向正在执行代码的那个对象实例。 作用： 访问当前对象的成员变量和方法。 区分局部变量和成员变量（当局部变量和成员变量同名时）。 调用当前类的其他构造方法（通过 this(参数)）。 this 可以作为参数传递给方法或构造器。 示例： class Student { private String name; // 构造方法 public Student(String name) { this.name = name; // 使用 this 区分局部变量和成员变量 } // 访问当前对象的方法 public void introduce() { System.out.println(&quot;My name is &quot; + this.name); } // 调用当前类的其他构造方法 public Student() { this(&quot;Unknown&quot;); // 调用带参数的构造方法 } } 2. super 关键字 定义：super 关键字代表当前对象中的父类型特征，即指向当前对象的直接父类对象。 作用： 访问父类的成员变量和方法。 调用父类的构造方法（通过 super(参数)），目的是为了完成父类型特征的初始化。 super 不能单独输出，必须用于访问父类的成员或调用父类的构造方法。 示例： class Animal { protected String name; public Animal(String name) { this.name = name; } public void move() { System.out.println(name + &quot; is moving&quot;); } } class Cat extends Animal { private String color; // 调用父类的构造方法 public Cat(String name, String color) { super(name); // 调用父类的构造方法 ，此处必须，因为父类没有无参构造方法，如果父类有无参构造方法，编译器会自动隐式添加 super（）； this.color = color; } // 重写父类的方法 @Override public void move() { super.move(); // 调用父类的 move() 方法 System.out.println(&quot;The cat is running&quot;); } // 访问父类的成员变量 public void printInfo() { System.out.println(&quot;Name: &quot; + super.name + &quot;, Color: &quot; + this.color); } } 3. super 和 this 的区别 特性 this super 代表的对象 当前对象的引用 当前对象的父类对象的引用 访问成员 访问当前类的成员变量和方法 访问父类的成员变量和方法 调用构造方法 调用当前类的其他构造方法（this(参数)） 调用父类的构造方法（super(参数)） 是否可以省略 大部分情况下可以省略 当父类和子类有同名成员时，super 不能省略 能否单独使用 可以单独使用（如 System.out.println(this);）当前对象的tostring方法 不能单独使用 使用场景 区分局部变量和成员变量、调用其他构造方法 访问父类成员、调用父类构造方法 是否能用于静态上下文 不能用于静态上下文 不能用于静态上下文 4. super 不能省略的情况 当父类和子类中定义了相同的属性（实例变量）或相同的方法（实例方法）时，如果需要在子类中访问父类的属性或方法，super. 不能省略。否则，默认访问的是子类中的成员。 示例： class Parent { protected int value = 10; public void showValue() { System.out.println(&quot;Parent value: &quot; + value); } } class Child extends Parent { private int value = 20; public void showValue() { System.out.println(&quot;Child value: &quot; + value); // 访问子类的 value System.out.println(&quot;Parent value: &quot; + super.value); // 访问父类的 value } } public class Main { public static void main(String[] args) { Child c = new Child(); c.showValue(); } } 输出结果： Child value: 20 Parent value: 10 5. super(实参) 的使用 调用父类的构造方法：super(实参) 用于在子类的构造方法中调用父类的构造方法，目的是为了完成父类型特征的初始化。 自动调用：如果一个构造方法的第一行没有显式地调用 super(实参) 或 this(实参)，系统会自动调用无参数的父类构造方法 super()。 位置限制：super(实参) 只能出现在构造方法的第一行。 示例： class Parent { public Parent() { System.out.println(&quot;Parent constructor called&quot;); } public Parent(String name) { System.out.println(&quot;Parent constructor with name: &quot; + name); } } class Child extends Parent { public Child() { super(); // 显式调用父类的无参数构造方法 System.out.println(&quot;Child constructor called&quot;); } public Child(String name) { super(name); // 显式调用父类的带参数构造方法 System.out.println(&quot;Child constructor with name: &quot; + name); } } public class Main { public static void main(String[] args) { Child c1 = new Child(); // 输出: Parent constructor called, Child constructor called Child c2 = new Child(&quot;Alice&quot;); // 输出: Parent constructor with name: Alice, Child constructor with name: Alice } } 6. Object 类的无参数构造方法 默认调用：在Java语言中，每个类都隐式或显式地继承自 Object 类。因此，无论你是否显式地调用了 super()，Object 类的无参数构造方法都会被执行。 建议：为了提高代码的可读性和明确性，建议显式地定义无参数构造方法，尤其是在你有多个构造方法的情况下。 示例： class MyClass { public MyClass() { super(); // 显式调用 Object 类的无参数构造方法 System.out.println(&quot;MyClass constructor called&quot;); } public MyClass(String name) { this(); // 调用无参数构造方法 System.out.println(&quot;MyClass constructor with name: &quot; + name); } } //实际上也可以 因为编译器会自动调用 class MyClass { public MyClass() { System.out.println(&quot;MyClass constructor called&quot;); } public MyClass(String name) { System.out.println(&quot;MyClass constructor with name: &quot; + name); } } public class Main { public static void main(String[] args) { MyClass obj1 = new MyClass(); // 输出: MyClass constructor called MyClass obj2 = new MyClass(&quot;Bob&quot;); // 输出: MyClass constructor called, MyClass constructor with name: Bob } } 总结 this 代表当前对象的引用，主要用于访问当前类的成员变量和方法，区分局部变量和成员变量，以及调用当前类的其他构造方法。 super 代表当前对象的父类对象的引用，主要用于访问父类的成员变量和方法，调用父类的构造方法。 super 不能用于静态上下文，并且在某些情况下（如父类和子类有同名成员时）不能省略。 super(实参) 用于调用父类的构造方法，必须放在构造方法的第一行，并且如果没有显式调用，系统会自动调用 super()。 Object 类的无参数构造方法 一定会被执行，建议显式地定义无参数构造方法以提高代码的可读性。 子类是一个扩展的大盒子： 子类并不是简单地“塞入”父类的内部，而是扩展了父类的盒子。子类继承了父类的所有属性和行为，并且可以在其基础上添加新的属性和行为，或者重写（覆盖）父类中的一些行为。 子类的盒子包含了父类的盒子的内容，并且在父类的基础上进行了扩展或修改。因此，子类的盒子比父类的盒子更大、更复杂，因为它不仅包含了父类的所有内容，还增加了自己的内容。 构造过程： 当你创建一个子类的对象时，实际上是在构建一个包含父类特征的完整对象。这个过程中，父类的构造方法会首先被调用，以确保父类的部分被正确初始化。然后，子类的构造方法继续执行，完成子类特有的初始化。 这个过程类似于先填充父类的“盒子”，然后再填充子类的“盒子”。父类的盒子是子类盒子的一部分，而不是被“塞入”子类盒子中。 多态性： 在运行时，Java 的虚拟机会根据实际对象的类型来决定调用哪个方法。这就好比你在外面看到的是一个大盒子（父类引用），但当你打开它时，里面可能有一个更大的盒子（子类对象），并且你会根据这个更大盒子的内容来决定如何操作它。 通过父类的引用可以访问子类对象的行为，但这并不是因为子类对象是“塞入”父类的，而是因为子类对象实现了父类的接口，并且可以通过父类的引用进行访问。这种行为是通过动态绑定实现的，即在运行时根据实际对象的类型来决定调用哪个方法。 为什么说“塞入一个小盒子”不完全准确？ 继承不是简单的嵌套：子类并不是简单地“塞入”父类的内部，而是扩展了父类。子类继承了父类的所有属性和方法，并且可以在其基础上进行扩展或修改。子类对象包含了父类的所有特征，但它不仅仅是一个“小盒子”放在“大盒子”里，而是一个更大、更复杂的盒子，它包含了父类的所有内容并添加了自己的内容。 构造顺序：在创建子类对象时，父类的构造方法会首先被调用，以确保父类的部分被正确初始化。然后，子类的构造方法才会执行。这个过程更像是先填充父类的“盒子”，再填充子类的“盒子”，而不是简单地把一个“小盒子”塞进“大盒子”。 多态性：通过父类的引用可以访问子类对象的行为，这并不意味着子类对象是“塞入”父类的，而是因为子类对象实现了父类的接口，并且可以通过父类的引用进行访问。这种行为是通过动态绑定实现的，即在运行时根据实际对象的类型来决定调用哪个方法。 总结 继承关系更像是一个扩展的过程，而不是简单地将一个“小盒子”塞入一个“大盒子”。子类继承了父类的所有属性和行为，并可以在其基础上进行扩展或修改。 构造过程是先初始化父类的部分，再初始化子类的部分，确保整个对象的状态是完整的。 多态性允许通过父类的引用访问子类对象的行为，但这并不是通过“塞入”实现的，而是通过动态绑定来实现的。 修正后的比喻 为了更准确地描述继承机制，可以说： 继承对象实际上相当于将父类的盒子扩展为一个更大的盒子，这个更大的盒子包含了父类的所有内容，并且在此基础上增加了子类特有的内容。子类的盒子不仅仅是“塞入”父类的盒子，而是扩展了父类的盒子，使得它可以容纳更多的功能和数据。 构造过程类似于先填充父类的“盒子”，再填充子类的“盒子”，确保整个对象的状态是完整的。 多态性允许通过父类的引用访问子类对象的行为，但这并不是通过“塞入”实现的，而是通过动态绑定来实现的 final关键字与常量 ①final修饰的类不能被继承 ②final修饰的方法不能被覆盖 ③final修饰的变量，一旦赋值不能重新赋值 ④final修饰的实例变量必须在对象初始化时手动赋值 ⑤final修饰的实例变量一般和static联合使用：称为常量 ⑥final修饰的引用，一旦指向某个对象后，不能再指向其它对象。但指向的对象内部的数据是可以修改的。 常量 * 1. 怎么定义常量：public static final 数据类型 常量名 = 常量值; * 2. 常量名的命名规范：全部单词大写，每个单词采用“_”衔接。 抽象类 在面向对象编程中，抽象类 是一种特殊的类，它不能被直接实例化，而是用于定义一个通用的接口或模板，供其子类继承和实现。 1. 什么时候考虑将类定义为抽象类？ 在面向对象编程中，抽象类 是一种特殊的类，它不能被直接实例化，而是用于定义一个通用的接口或模板，供其子类继承和实现。通常，当你遇到以下情况时，可以考虑将类定义为抽象类： 某些方法无法实现或没有意义：如果一个类中有一些方法在该类中无法实现，或者实现这些方法没有实际意义，那么可以将这些方法定义为抽象方法。抽象方法没有具体的实现，而是要求子类必须提供具体的实现。例如，Person 类中的 greet() 方法，不同国家的人有不同的问候方式，因此 greet() 的具体实现应该由子类来完成。 提供公共代码和模板：抽象类可以包含已经实现的方法（非抽象方法），这些方法可以为所有子类提供共享的行为。同时，抽象类还可以定义一些抽象方法，要求子类根据具体需求进行实现。这样，抽象类既提供了通用的功能，又允许子类根据具体情况定制特定的行为。 强制子类实现某些方法：通过定义抽象方法，你可以确保所有继承该抽象类的子类都必须实现这些方法，从而保证了子类的一致性和完整性。 2. 抽象类的定义 抽象类使用 abstract 关键字来定义。语法如下： abstract class 类名 { // 类的内容 } 抽象类的特点 ： 不能实例化：你不能直接创建抽象类的对象。例如，如果你有一个抽象类 Animal，你不能写 new Animal()。 可以有构造方法：尽管抽象类不能被实例化，但它仍然可以有构造方法。这些构造方法主要用于初始化子类对象时调用，帮助子类完成必要的初始化工作。 可以有普通方法：抽象类不仅可以包含抽象方法，还可以包含已经实现的普通方法。这些普通方法可以在子类中直接使用，或者被子类重写。 3. 抽象方法的定义 抽象方法是只有声明而没有具体实现的方法。它们必须在抽象类中定义，并且要求子类必须实现这些方法。抽象方法的语法如下： abstract 返回值类型 方法名(参数列表); 抽象方法的特点 ： 没有方法体：抽象方法只有方法签名，没有方法体（即没有 {} 和具体实现）。 必须在抽象类中定义：抽象方法只能在抽象类中定义，普通类中不能定义抽象方法。 子类必须实现：如果一个类继承了抽象类并且不是抽象类，那么它必须实现所有抽象方法。否则，该类也必须被声明为抽象类。 4. 抽象类与普通类的区别 特性 抽象类 普通类 是否可以实例化 不可以 可以 是否可以有构造方法 可以，但只能用于子类初始化 可以，用于创建对象 是否可以有抽象方法 可以 不可以 是否可以有普通方法 可以 可以 子类是否必须实现抽象方法 如果子类不是抽象类，必须实现所有抽象方法 无此要求 5. 抽象类的使用场景示例 示例 1：Person 类中的 greet() 方法 假设我们有一个 Person 类，不同国家的人有不同的问候方式。我们可以将 Person 定义为抽象类，并将 greet() 定义为抽象方法，让子类根据具体情况进行实现。 abstract class Person { // 公共属性 protected String name; // 构造方法 public Person(String name) { this.name = name; } // 抽象方法：不同国家的人有不同的问候方式 abstract void greet(); // 已实现的方法：所有人都可以打招呼 void sayHello() { System.out.println(&quot;Hello, my name is &quot; + name); } } // 子类 ChinesePerson 实现 greet() 方法 class ChinesePerson extends Person { public ChinesePerson(String name) { super(name); } @Override void greet() { System.out.println(&quot;你好，我叫 &quot; + name); } } // 子类 AmericanPerson 实现 greet() 方法 class AmericanPerson extends Person { public AmericanPerson(String name) { super(name); } @Override void greet() { System.out.println(&quot;Hi, I'm &quot; + name); } } public class Main { public static void main(String[] args) { Person chinese = new ChinesePerson(&quot;李华&quot;); chinese.greet(); // 输出：你好，我叫李华 chinese.sayHello(); // 输出：Hello, my name is 李华 Person american = new AmericanPerson(&quot;John&quot;); american.greet(); // 输出：Hi, I'm John american.sayHello(); // 输出：Hello, my name is John } } 示例 2：Pet 类中的 eat() 方法 假设我们有一个 Pet 类，表示宠物。不同的宠物有不同的进食方式，因此 eat() 方法的具体实现应该由子类来完成。我们可以将 Pet 定义为抽象类，并将 eat() 定义为抽象方法。 abstract class Pet { // 公共属性 protected String name; // 构造方法 public Pet(String name) { this.name = name; } // 抽象方法：不同宠物有不同的进食方式 abstract void eat(); // 已实现的方法：所有宠物都可以玩耍 void play() { System.out.println(name + &quot; is playing&quot;); } } // 子类 Dog 实现 eat() 方法 class Dog extends Pet { public Dog(String name) { super(name); } @Override void eat() { System.out.println(name + &quot; is eating dog food&quot;); } } // 子类 Cat 实现 eat() 方法 class Cat extends Pet { public Cat(String name) { super(name); } @Override void eat() { System.out.println(name + &quot; is eating cat food&quot;); } } public class Main { public static void main(String[] args) { Pet dog = new Dog(&quot;Buddy&quot;); dog.eat(); // 输出：Buddy is eating dog food dog.play(); // 输出：Buddy is playing Pet cat = new Cat(&quot;Whiskers&quot;); cat.eat(); // 输出：Whiskers is eating cat food cat.play(); // 输出：Whiskers is playing } } 6. 抽象类的注意事项 抽象类不能被实例化：不能直接创建抽象类的对象。例如，new Pet() 会报编译错误。 抽象类可以有构造方法：虽然抽象类不能被实例化，但它仍然可以有构造方法。这些构造方法用于初始化子类对象时调用，帮助子类完成必要的初始化工作。 抽象类可以有普通方法：抽象类不仅可以包含抽象方法，还可以包含已经实现的普通方法。这些普通方法可以在子类中直接使用，或者被子类重写。 抽象类中不一定有抽象方法：虽然抽象类通常包含抽象方法，但并不是必须的。一个类只要被声明为 abstract，即使它没有任何抽象方法，也不能被实例化。 非抽象类继承抽象类时必须实现所有抽象方法：如果一个非抽象类继承了抽象类，那么它必须实现所有抽象方法。否则，该类也必须被声明为抽象类。 abstract 关键字不能与 private、final、static 共存： private：抽象方法必须被子类实现，而 private 方法无法被子类访问，因此二者不能共存。 final：final 方法不能被子类重写，而抽象方法必须被子类重写，因此二者不能共存。 static：静态方法属于类本身，而不是类的实例，因此不能与抽象方法共存，因为抽象方法需要在子类实例中实现。 接口 1. 什么是接口？ 在 Java 中，接口（interface）是一种完全抽象的引用类型，它定义了一组行为规范或契约。接口用于描述实现该接口的类应该具有哪些方法和常量，但不提供具体的实现。接口的主要作用是定义一组公共的行为，确保所有实现者都遵循相同的行为规则。 2. 接口的作用 定义行为规范：接口定义了一组抽象方法，这些方法描述了实现该接口的类必须提供的功能。通过接口，你可以确保所有实现者都遵循相同的契约。 解耦合：接口允许调用者和实现者之间保持松散的耦合关系。调用者只需要依赖接口，而不关心具体的实现者是谁。这种设计模式称为面向接口编程，它有助于提高代码的可维护性和扩展性。 多继承支持：一个类可以实现多个接口，从而组合不同的行为。这弥补了 Java 单继承的限制，使得类可以从多个来源继承行为。 3. 接口的定义 接口使用 interface 关键字来定义。语法如下： [修饰符列表] interface 接口名 { // 常量 // 抽象方法 // 默认方法（Java 8+） // 静态方法（Java 8+） // 私有方法（Java 9+） } 常量：接口中可以定义常量，默认为 public static final，因此你可以省略这些修饰符。因此，必须赋值 抽象方法：接口中的方法默认是抽象的，即没有具体实现。你也可以显式地使用 abstract 关键字，但这不是必需的。 默认方法（Java 8+）：接口可以包含默认方法，使用 default 关键字定义。默认方法提供了可选的实现，允许实现类选择是否重写这些方法。 在 Java 8 之前，接口只能定义抽象方法，所有实现接口的类都必须提供这些抽象方法的具体实现。这带来了一个问题：如果你需要向接口添加新方法，那么所有实现该接口的类都需要修改以实现这个新方法。这种现象被称为接口演变问题。 为了解决这个问题，Java 8 引入了默认方法（default 方法）。默认方法允许你在接口中为某个方法提供一个可选的实现。这样一来，即使你向接口添加了新方法，现有的实现类也不需要强制实现这些新方法，因为它们可以使用接口提供的默认实现。 简单来说，默认方法 就是接口中已经实现了的方法，子类可以选择是否重写它。如果子类不重写，默认方法的实现仍然有效。 想象一下，你有一个 Usb 接口，定义了 read() 和 write() 方法。现在你想为所有 USB 设备添加一个新的功能：打印设备信息（printInfo()）。如果你直接在接口中添加这个方法，那么所有实现 Usb 接口的类（如 Printer、HardDrive 等）都需要修改以实现 printInfo() 方法。这显然不太方便，尤其是当你有很多实现类时。 通过引入默认方法，你可以直接在接口中为 printInfo() 提供一个默认实现。这样，所有现有的实现类都可以继续正常工作，而不需要修改。只有那些想要自定义 printInfo() 实现的类才需要重写这个方法。 静态方法（Java 8+）：接口可以包含静态方法，使用 static 关键字定义。静态方法属于接口本身，而不是实现类，因此它们只能通过接口名调用。 私有方法（Java 9+）：接口可以定义私有方法，使用 private 关键字定义。私有方法通常用于辅助默认方法或静态方法的实现，避免代码重复。 4. 接口的实现 类可以通过 implements 关键字实现接口。实现接口的类必须提供接口中所有抽象方法的具体实现。如果类没有实现所有抽象方法，则该类也必须被声明为抽象类。 class 类名 implements 接口名, 接口名2, ... { // 实现接口中的抽象方法 } 5. 接口的特性 不能实例化：接口不能被直接实例化，因为它是完全抽象的。你可以创建接口的引用变量，但不能创建接口的对象。 隐式继承 Object：所有接口都隐式继承自 Object 类，因此接口可以调用 Object 类的相关方法，如 toString()、equals() 等。 多继承支持：一个类可以实现多个接口，从而组合不同的行为。这是 Java 中实现多继承的一种方式。 常量和方法的访问修饰符：接口中的所有常量默认为 public static final，所有方法默认为 public。因此，你可以省略这些修饰符。 6. 接口的示例 示例 1：定义一个 Usb 接口 假设我们有一个 Usb 接口，定义了 read() 和 write() 方法。任何实现 Usb 接口的设备都必须提供这两个方法的具体实现。 // 定义 Usb 接口 interface Usb { void read(); void write(); // 默认方法：提供一个可选的实现 default void printInfo() { System.out.println(&quot;This is a USB device.&quot;); } // 静态方法：提供一个工具类方法 static void checkConnection() { System.out.println(&quot;Checking USB connection...&quot;); } } 示例 2：实现 Usb 接口的 Printer 和 HardDrive 类 // 实现 Usb 接口的打印机类 class Printer implements Usb { @Override public void read() { System.out.println(&quot;Printer is reading data...&quot;); } @Override public void write() { System.out.println(&quot;Printer is printing data...&quot;); } } // 实现 Usb 接口的硬盘类 class HardDrive implements Usb { @Override public void read() { System.out.println(&quot;HardDrive is reading data...&quot;); } @Override public void write() { System.out.println(&quot;HardDrive is writing data...&quot;); } } 示例 3：Computer 类作为调用者 // Computer 类作为调用者，面向 Usb 接口进行编程 class Computer { public void conn(Usb usb) { usb.read(); usb.write(); usb.printInfo(); // 调用默认方法 Usb.checkConnection(); // 调用静态方法 } } public class Main { public static void main(String[] args) { Computer computer = new Computer(); // 连接打印机 Usb printer = new Printer(); computer.conn(printer); // 连接硬盘 Usb hardDrive = new HardDrive(); computer.conn(hardDrive); } } 在这个例子中，Computer 类只需要依赖 Usb 接口，而不关心具体的设备类型。这样，我们可以轻松地添加新的设备（如 Mouse 或 Keyboard），而不需要修改 Computer 类的代码。这就是面向接口编程的优势：调用者和实现者之间的解耦合。 抽象类与接口的对比 1. 抽象类 vs 接口：基础概念 特性 抽象类 接口 定义 抽象类是一种特殊的类，不能被实例化，但可以包含已实现的方法和抽象方法。 接口是一种完全抽象的引用类型，只定义抽象方法和常量，无法实例化。 关键字 abstract class interface 构造方法 可以有构造方法，但只能用于子类初始化。 没有构造方法，无法实例化。 继承方式 一个类只能继承一个抽象类（单继承）。 一个类可以实现多个接口（多继承）。 实现方式 使用 extends 关键字继承抽象类。 使用 implements 关键字实现接口。 抽象方法 可以有抽象方法，也可以有已实现的方法。 只能定义抽象方法（Java 8 之前），Java 8 之后可以有默认方法和静态方法，也可以有普通方法。Java9后加入私有方法，Java16引入密闭接口 常量 可以有普通变量和常量。 只能定义常量，默认为 public static final。 访问修饰符 方法和变量可以有不同的访问修饰符。 所有的方法和变量默认为 public。 继承 Object 继承自 Object 类。 隐式继承 Object 类。 2. 抽象类的特点 部分实现：抽象类可以包含已实现的方法，这些方法可以直接在子类中使用，或者被子类重写。这使得抽象类适合用于定义一些通用的行为，同时允许子类根据具体需求进行扩展。 单继承限制：一个类只能继承一个抽象类，这意味着如果你需要从多个类中继承行为，必须使用接口或其他设计模式（如组合）。 构造方法：抽象类可以有构造方法，尽管它不能被直接实例化，但这些构造方法可以在子类构造时调用，帮助子类完成必要的初始化工作。 灵活性较低：由于抽象类只能单继承，因此它的灵活性相对较低，尤其是在复杂的继承关系中，可能会导致代码难以维护。 3. 接口的特点 完全抽象：接口是完全抽象的，它只定义了一组方法和常量，没有任何具体的实现。所有实现接口的类都必须提供这些方法的具体实现。这使得接口非常适合用于定义契约或规范，确保所有实现者都遵循相同的行为规则。 多继承支持：一个类可以实现多个接口，这使得接口具有更高的灵活性。你可以通过实现多个接口来组合不同的行为，而不需要依赖于类的继承层次结构。 默认方法和静态方法：从 Java 8 开始，接口可以包含默认方法（default）和静态方法（static）。默认方法允许接口提供一些可选的实现，而静态方法则可以为接口提供工具类方法。这解决了接口演变问题，即当接口添加新方法时，现有的实现类不需要强制实现这些新方法。 私有方法：从 Java 9 开始，接口可以定义私有方法（private），这些方法可以用于辅助默认方法或静态方法的实现，避免代码重复。 解耦合：接口的最大优势在于它能够实现解耦合。调用者（如 Computer 类）只需要依赖接口，而不关心具体的实现者（如 Printer 或 HardDrive）。这种设计使得系统的各个模块可以独立开发和测试，降低了系统的耦合度，提高了扩展性和维护性。 4. 抽象类与接口的选择原则 在实际开发中，选择使用抽象类还是接口取决于具体的需求和设计目标。以下是一些常见的选择原则： 如果需要定义一组共同的行为，并且这些行为中有部分是可以共享的实现，那么应该使用抽象类。抽象类可以包含已实现的方法，帮助子类减少重复代码。 如果需要定义一组行为规范，但不希望提供任何具体的实现，并且希望允许多个类实现这些行为，那么应该使用接口。接口更适合用于定义契约或规范，确保所有实现者都遵循相同的行为规则。 如果需要允许多个类组合不同的行为，那么应该使用接口。接口支持多继承，允许一个类实现多个接口，从而组合不同的行为。 如果需要解决接口演变问题，即当接口添加新方法时，不想强制所有实现类都实现这些新方法，那么应该使用接口中的默认方法（Java 8 之后引入）。默认方法允许接口提供可选的实现，减少了对现有代码的破坏。 5. 抽象类与接口的结合使用 在某些情况下，抽象类和接口可以结合使用，以充分利用两者的优势。例如： 抽象类作为基类，接口作为行为规范：你可以定义一个抽象类来提供一些通用的实现，同时让该抽象类实现一个或多个接口，以确保所有子类都遵循特定的行为规范。这样，你既可以享受抽象类提供的共享实现，又可以通过接口实现解耦合。 接口作为顶层规范，抽象类作为中间层：你可以定义一个接口来描述系统中所有组件的行为规范，然后创建一个抽象类来实现该接口，并提供一些通用的实现。子类可以继承这个抽象类，并根据具体需求进一步扩展。这种方式可以有效地组织代码结构，降低复杂度。 6. 接口的演变问题及解决方案 在早期版本的 Java 中，接口只能定义抽象方法，所有实现接口的类都必须实现这些方法。这导致了一个问题：当你向接口添加新方法时，所有实现该接口的类都需要修改以实现新方法。这种现象被称为接口演变问题。 为了应对这一问题，Java 8 引入了默认方法（default）和静态方法（static）。默认方法允许接口提供可选的实现，而静态方法则可以为接口提供工具类方法。这样一来，即使接口添加了新方法，现有的实现类也不需要强制实现这些新方法，从而减少了对现有代码的破坏。 例如： interface Usb { void read(); void write(); // 默认方法：提供一个可选的实现 default void printInfo() { System.out.println(&quot;This is a USB device.&quot;); } // 静态方法：提供一个工具类方法 static void checkConnection() { System.out.println(&quot;Checking USB connection...&quot;); } } 7.密封接口 1. 什么是密封接口？ 密封接口是一种特殊的接口，它可以通过 sealed 关键字来限制哪些类或接口可以实现它。密封接口的主要目的是控制继承关系，确保只有指定的类或接口能够扩展或实现该接口。这与密封类（Sealed Classes）类似，但应用于接口。 密封接口通常用于以下场景： 防止滥用：确保只有特定的类或接口能够实现某个接口，避免其他类随意扩展。 增强安全性：通过限制实现者的范围，减少潜在的安全风险。 提高代码的可维护性：通过明确的继承关系，使代码更加清晰和易于维护。 2. 如何定义密封接口？ 要定义一个密封接口，你需要在接口声明中使用 sealed 关键字，并使用 permits 子句来指定哪些类或接口可以实现该接口。permits 后面列出的类或接口是唯一可以实现该密封接口的类或接口。 语法如下： public sealed interface InterfaceName permits ClassName1, ClassName2, ... { // 接口内容 } 3. 密封接口的实现类或接口 密封接口的实现类或接口必须满足以下条件之一： final 类：实现密封接口的类可以是 final 类，表示该类不能再被继承。 sealed 类：实现密封接口的类也可以是密封类，进一步限制其子类。 non-sealed 类：实现密封接口的类可以是 non-sealed 类，表示该类可以被其他类继承。 8. 总结 抽象类 和 接口 都是用于定义抽象行为和规范的工具，但它们在使用场景、语法和功能上有显著差异。 抽象类 适合用于定义部分实现的基类，允许子类继承并扩展其行为；而 接口 则更适合用于定义完全抽象的行为规范，允许多个类实现这些规范。 接口 的最大优势在于它能够实现解耦合，使得调用者和实现者之间保持松散的耦合关系，降低了系统的耦合度，提高了扩展性和维护性。 面向接口编程 是一种重要的设计模式，它通过接口将调用者和实现者分离，使得系统更加灵活和易于扩展。 访问权限 ①访问权限控制符不能修饰局部变量。 ①类中的属性和方法访问权限共有四种：private、缺省、protected和public。 ②类的访问权限只有两种：public和 缺省。 ","link":"https://blog.randomname.me/post/t6AuxRk6LY/"},{"title":"Scaleway Ipv6 only 0.23欧每月的开机和DD系统","content":" 前置要求 支付方式（推荐顺序从高到低） 根据实际操作经验，通过以下支付方式完成付款更快地通过 KYC（身份认证），从而实现快速开通服务器。请务必确保支付方式支持 3DS 验证： 优选方式：大陆地区卡 bin 绑定云闪付的银联信用卡 最推荐，验证速度更快。 大陆地区卡 bin 绑定云闪付的银联借记卡（适合注册绑定时使用）。 大陆卡 bin 无法直接绑定至云闪付，但可以通过手机银行绑定的卡组织信用/借记卡： 是否可用取决于手机银行支持账单实时查询的完善程度。 示例：交通银行运通卡和工商银行 VISA 卡。尽管能实时显示预授权，但账单信息可能不完整。账单日临近时，可通过电子账单完成验证。 非大陆地区卡 bin（国外卡组织信用/借记卡）： 不推荐：国外多半存在预授权信息实时显示延迟的情况，例如 OCBC 的账单不会实时显示。 虚拟卡（如 WISE)： 不推荐：虽然能显示简略的实时预授权信息，但不提供完整账单或者电子账单。 2. 智能手机（可选） 使用手机 CLI 操作（命令行工具）可直接粘贴命令，避免手动输入带来的错误并提升效率。 电脑版网页无法直接复制粘贴命令（若有解决方法，欢迎赐教）。 3. IPv6 网络要求 注册过程中及后续 SSH 连接需要支持 IPv6 的网络。如果现有网络无 IPv6，可以通过： 手机流量开热点。 或设置 IPv6 出站的跳板机 来完成。 注册 Scaleway 账户并设置 SSH 密钥 （1）注册账户 访问官网：Scaleway 官网。 填写地址信息：可随意填写，无需担忧后续支付验证步骤会受影响。 绑定银行卡： 对于 银联卡：确保已绑定到 云闪付 App，并完成一笔利用商户测试的实际消费（如消费路径：微信/支付宝 → 云闪付账单同步查看实测效果）。 其他卡组织若无手机银行支持账单同步，可尝试等待电子账单生成并完成验证： 在注册时填写银行卡信息，完成 3DS 验证，如出现无法弹出 3DS 验证窗口请科学上网。 如果未能及时验证，可选择稍后验证（验证有效期 10 天），等账单更新后补充 4 位预授权码。 完成支付验证：前往 Scaleway 官方控制台，找到添加的银行卡，依提示输入账单生成的 4 位验证码完成验证。 （2）生成并上传 SSH 密钥 为了确保日后系统可通过 SSH 控制，请提前生成 SSH 登录密钥： 推荐工具： Windows 用户推荐 PuTTYgen 生成 Ed25519 类型的 SSH Key。 可选工具：如 Termius（路径：Vaults → Keychain → Generate Key）。 上传密钥：进入 Scaleway 官网 → 点击右上角头像 → SSH Keys → Add SSH Key，上传生成的公钥。 备用说明： 本教程最后的登录方法无需密钥，仅需密码即可连接 SSH。 如果需要保留密钥登录，请妥善保存私钥。 2. 创建实例并调整硬盘配置 （1）创建云服务器实例 最低配（1C1G）服务器目前支持三个区域： 法国巴黎一区（FR PARIS 1）【可能需要 CLI 命令绕过地域限制】 荷兰阿姆斯特丹一区（NL AMSTERDAM 1） 波兰华沙二区（PL WARSAW 2） 方法一：通过网页 GUI 创建（适用于荷兰/波兰，法国根据资源情况决定） 访问实例创建页面： 点击主页面上方【Create】→ 【Instance】→ 【Create an Instance】。 选择资源区域：选择一个区域（如 NL AMSTERDAM 1 或 PL WARSAW 2）。 配置实例参数： 【型号 &amp; 名称】：选择 STARDUST1-S 规格并命名实例（任意名称）。 【镜像选择】：建议选择 Debian 或 Ubuntu 系列，其它镜像可供后续手动更换。 【硬盘设置】：默认分配 10GB 磁盘，但为了降低费用，建议编辑为 3GB Local 磁盘。 【网络设置】：选中 Public IPv6，取消勾选 Public IPv4（避免额外费用）。 【与 SSH 密钥关联**】: 添加您之前生成的 SSH Key 文件。 确认费用：点击费用预览确认无误后点击【Create Instance】完成创建。 方法二：使用 CLI 命令行创建实例且支持法国节点 在控制台右上角点击 CLI，根据需求输入以下命令（默认创建 10GB 硬盘）： bash复制代码 法国（PARIS 1） scw instance server create zone=fr-par-1 root-volume=local:10GB name=fr type=STARDUST1-S ipv6=true ip=none 荷兰（AMSTERDAM 1） scw instance server create zone=nl-ams-1 root-volume=local:10GB name=nl type=STARDUST1-S ipv6=true ip=none 波兰（WARSAW 2） scw instance server create zone=pl-waw-2 root-volume=local:10GB name=pl type=STARDUST1-S ipv6=true ip=none （2）调整硬盘配置 添加防火墙规则： 打开实例控制台 → Security group → 添加所有协议的入栈/出栈 Accept 规则。 关闭实例并解绑 10GB 硬盘： 实例控制台内关闭实例 → 解绑默认 10GB 硬盘。 删除 10GB 硬盘并创建新的 3GB 本地硬盘： 分别删除旧存储并新建一个 3GB 的 Local Storage。 救援系统模式： 进入实例高级设置 → Boot 使用救援镜像 → 启动 Rescue Reboot 模式。 3. 重装系统（以 Debian 为例） （1）下载并写入镜像 通过 SSH 登录 rescue 模式后执行以下命令（可选压缩或未压缩镜像）： bash复制代码 下载并写入未压缩镜像（推荐）： curl -Lo- &quot;https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-nocloud-amd64.raw&quot; | dd of=/dev/vda bs=1M 或下载并写入压缩镜像： curl -Lo- &quot;https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-nocloud-amd64.tar.xz&quot; | tar -xJO | dd of=/dev/vda bs=1M （2）扩展分区并修复 确定磁盘序号为 /dev/vda 后，依次执行以下命令： bash复制代码 parted -s /dev/vda resizepart 1 100% e2fsck -f /dev/vda1 resize2fs /dev/vda1 （3）重新启动并启用本地启动模式 完成重装后，通过控制台将启动模式切换回 Use local boot，重启实例。 添加 WARP 接口（免费获取 IPv4 网络） 在 IPv6 环境下，通过 SSH 登录实例后运行以下命令： bash复制代码 wget -N https://gitlab.com/fscarmen/warp/-/raw/main/menu.sh &amp;&amp; bash menu.sh 按照提示完成安装，即可获得由 Cloudflare 提供的免费 IPv4 出站接口（也支持 IPv6）。 ","link":"https://blog.randomname.me/post/scaleway-ipv6-only-023-ou-mei-yue-de-kai-ji-he-dd-xi-tong/"}]}